<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Tower Defense</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation;
            background-color: #111827;
        }
        canvas {
            background-color: #262626;
            border: 2px solid #4ade80;
            border-radius: 0.5rem;
            cursor: pointer;
            width: 100%;
            height: auto;
            max-width: 800px;
        }
        .btn {
            @apply px-6 py-3 bg-blue-600 text-white text-lg font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition duration-150 ease-in-out disabled:opacity-50;
            background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent);
            background-size: 20px 20px;
        }
        .btn-tower {
            @apply px-4 py-2 bg-green-600 text-white font-medium rounded-lg shadow-sm hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 transition duration-150 ease-in-out;
            background-image: linear-gradient(45deg, rgba(0, 0, 0, 0.1) 25%, transparent 25%, transparent 50%, rgba(0, 0, 0, 0.1) 50%, rgba(0, 0, 0, 0.1) 75%, transparent 75%, transparent);
            background-size: 20px 20px;
        }
        /* --- NEW: Texture/Style for new towers --- */
        .btn-tower.style-LIGHTNING {
            background-image: linear-gradient(45deg, #a855f7 25%, #d8b4fe 25%, #d8b4fe 50%, #a855f7 50%, #a855f7 75%, #d8b4fe 75%, #d8b4fe 100%);
            background-size: 28.28px 28.28px;
            @apply hover:opacity-80;
        }
        .btn-tower.style-RAILGUN {
            @apply bg-gray-700 hover:bg-gray-600 text-yellow-300 border-2 border-yellow-400;
        }
        .btn-tower.style-BUFF {
            background-image: linear-gradient(135deg, #fde047 25%, #fef9c3 25%, #fef9c3 50%, #fde047 50%, #fde047 75%, #fef9c3 75%, #fef9c3 100%);
            background-size: 28.28px 28.28px;
            @apply text-gray-800 hover:opacity-80;
        }
        .btn-tower.style-BANK {
            @apply bg-green-800 hover:bg-green-700 text-white border-2 border-green-400;
        }
        /* --- END NEW STYLES --- */
        
        .btn-tower.selected {
            /* Highlight when selected for placement (single or continuous) */
            @apply bg-yellow-500 text-white ring-4 ring-yellow-300;
        }
        .btn-speed {
            @apply px-3 py-1 bg-gray-700 text-gray-100 text-sm font-medium rounded-lg hover:bg-gray-600 transition duration-150 ease-in-out;
        }
        .btn-speed.active {
            @apply bg-purple-600 ring-2 ring-purple-300;
        }
        /* Style for debug toggle button */
        .btn-debug {
            @apply px-3 py-1 bg-red-700 text-white text-sm font-medium rounded-lg shadow-sm hover:bg-red-600 transition duration-150 ease-in-out;
        }

        /* Continuous Placement Button - The dedicated toggle button */
        #continuousPlacementButton {
            @apply w-full text-center px-4 py-2 bg-indigo-600 text-white font-medium rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75 transition duration-150 ease-in-out;
        }
        /* New: Active state for the dedicated continuous button */
        #continuousPlacementButton:not(:disabled) {
            @apply hover:bg-indigo-700;
        }
        #continuousPlacementButton.active:not(:disabled) {
            @apply bg-pink-500 ring-4 ring-pink-300 hover:bg-pink-600;
        }
        
        /* NEW: Upgrade button style with texture */
        .btn-upgrade {
            @apply w-full px-4 py-3 bg-yellow-500 text-gray-900 font-bold rounded-lg shadow-md hover:bg-yellow-400 transition duration-150 ease-in-out disabled:opacity-50 disabled:hover:bg-yellow-500 disabled:cursor-not-allowed;
            background-image: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.2) 50%, rgba(255, 255, 255, 0.2) 75%, transparent 75%, transparent);
            background-size: 20px 20px;
        }
        .btn-sell {
             @apply w-full px-4 py-3 bg-red-600 text-white font-bold rounded-lg shadow-md hover:bg-red-500 transition duration-150 ease-in-out;
             background-image: linear-gradient(135deg, rgba(0, 0, 0, 0.2) 25%, transparent 25%, transparent 50%, rgba(0, 0, 0, 0.2) 50%, rgba(0, 0, 0, 0.2) 75%, transparent 75%, transparent);
             background-size: 20px 20px;
        }


        /* Modal specific styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
        }
        .modal-content {
            background-color: #1f2937;
            margin: 10% auto;
            padding: 20px;
            border: 2px solid #60a5fa;
            border-radius: 12px;
            width: 90%;
            max-width: 400px;
            color: #f3f4f6;
        }
        .modal-close {
            color: #d1d5db;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .modal-close:hover,
        .modal-close:focus {
            color: #ef4444;
            text-decoration: none;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-gray-900 min-h-screen flex flex-col items-center justify-center p-4 relative">

    <!-- Debug Menu Overlay -->
    <div id="debugMenu" class="absolute top-2 left-2 md:top-8 md:left-8 p-3 bg-gray-900 bg-opacity-80 rounded-lg text-xs font-mono text-green-400 z-50 hidden shadow-xl">
        <h3 class="font-bold border-b border-green-700 mb-1">DEBUG STATS</h3>
        <!-- Content injected by JS -->
    </div>

    <!-- Main Menu Container -->
    <div id="mainMenuContainer" class="w-full max-w-4xl text-center p-8">
        <h1 class="text-4xl font-bold text-gray-100 mb-8">Simple TD</h1>
        <h2 class="text-2xl font-semibold text-gray-300 mb-4">Select a Level</h2>
        <!-- Level buttons injected by JS -->
        <div id="levelSelector" class="grid grid-cols-1 md:grid-cols-3 gap-4 justify-center mb-8">
        </div>
        <button id="menuStartButton" class="btn" disabled>Start Game</button>
        <p id="levelMessage" class="mt-4 text-red-400"></p>
    </div>

    <!-- Game UI Container -->
    <div id="gameUiContainer" class="w-full max-w-4xl bg-gray-800 rounded-xl shadow-2xl p-4 md:p-6 hidden flex flex-col gap-4">
        
        <!-- Stats Bar -->
        <div class="flex flex-col md:flex-row justify-between items-center bg-gray-700 p-4 rounded-lg text-center md:text-left">
            <div class="text-2xl font-bold text-white mb-2 md:mb-0">
                Money: $<span id="money">200</span>
            </div>
            <div class="text-2xl font-bold text-white mb-2 md:mb-0">
                Lives: <span id="lives">50</span>
            </div>
            <div class="text-2xl font-bold text-white mb-2 md:mb-0">
                Wave: <span id="wave">0</span>
            </div>
        </div>

        <!-- Row 2: Canvas and Controls Panel -->
        <div class="flex flex-col md:flex-row gap-4">
            
            <!-- Game Canvas -->
            <div class="flex-grow">
                <canvas id="gameCanvas" width="800" height="600"></canvas>
            </div>

            <!-- Controls Panel (SIDEBAR) -->
            <div class="w-full md:w-48 bg-gray-900 p-4 rounded-lg shadow-inner flex-shrink-0">
                <h2 class="text-xl font-semibold mb-4 text-center text-gray-100">Controls</h2>
                <div class="flex flex-col gap-4">
                    <button id="startButton" class="btn" disabled>Start Wave</button>
                    
                    <!-- Speed Control Buttons -->
                    <div class="text-gray-300 text-sm font-medium mt-2 border-t border-gray-700 pt-3">Game Speed:</div>
                    <div class="flex justify-between gap-1">
                        <button id="speed1x" class="btn-speed active">1x</button>
                        <button id="speed2x" class="btn-speed">2x</button>
                        <button id="speed4x" class="btn-speed">4x</button>
                    </div>

                    <!-- Debug and Placement Options -->
                    <div class="flex flex-col gap-2 mt-4">
                        <button id="optionsButton" class="btn-tower bg-yellow-600 hover:bg-yellow-700">Options</button>
                        <button id="debugToggleBtn" class="btn-debug">Toggle Debug</button>
                        <div class="flex items-center justify-center gap-2">
                            <input type="checkbox" id="freePlacementCheckbox" class="w-4 h-4 rounded bg-gray-700 border-gray-600 text-blue-500 focus:ring-blue-600 focus:ring-2">
                            <label for="freePlacementCheckbox" class="text-sm font-medium text-gray-100">Free Placement</label>
                        </div>
                         <!-- Continuous Placement Button - MOVED -->
                        <button id="continuousPlacementButton" class="w-full mt-2">
                            Continuous Placement
                        </button>
                    </div>
                    <div id="messageBox" class="text-center font-medium text-red-400 h-8"></div>
                </div>
            </div>
        </div>

        <!-- Row 3: Tower Buy Section (Moved to the bottom) -->
        <div id="tower-buy-container" class="bg-gray-900 p-4 rounded-lg shadow-inner">
            <h3 class="text-xl font-semibold text-gray-100 mb-4 border-b border-gray-700 pb-2">Buy Towers</h3>

            <!-- Tower Purchase Buttons Container (Responsive Grid) -->
            <div id="towerPurchaseButtons" class="grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-3 mb-4">
                <!-- Buttons injected by JS for dynamic cost display -->
            </div>

            <!-- Continuous Placement Button was moved -->
        </div>


    </div>

    <!-- Tower Customization/Management Modal -->
    <div id="towerModal" class="modal">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <h2 class="text-2xl font-bold mb-4 text-center">Tower Management</h2>
            
            <div id="towerStats" class="mb-4 bg-gray-700 p-3 rounded-lg">
                <p>Damage: <span id="statDamage" class="font-bold text-green-400"></span></p>
                <p>Range: <span id="statRange" class="font-bold text-blue-400"></span></p>
                <p>Fire Rate: <span id="statFireRate" class="font-bold text-yellow-400"></span> s</p>
                <!-- Other stats like slow/splash can be added here if needed -->
            </div>

            <!-- Priority Options & Sell Button are dynamically injected into priorityOptions -->
            <div id="priorityOptions" class="space-y-3">
                <!-- Content injected by JS (Level, Upgrade, Sell, Priority) -->
            </div>
        </div>
    </div>
    
    <!-- Options Modal -->
    <div id="optionsModal" class="modal">
        <div class="modal-content">
            <span id="optionsModalClose" class="modal-close">&times;</span>
            <h2 class="text-2xl font-bold mb-4 text-center">Game Options</h2>
            
            <div class="space-y-4">
                <p class="text-sm text-gray-400">Customize your game experience and management.</p>
                
                <!-- NEW: Volume Control -->
                <div class="flex flex-col">
                    <label for="volumeSlider" class="mb-2 text-gray-300">Master Volume</label>
                    <input type="range" id="volumeSlider" min="-40" max="0" value="-10" class="w-full h-2 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- Toggle Sound Button -->
                <button id="toggleSoundButton" class="w-full px-4 py-3 bg-gray-600 text-white font-medium rounded-lg shadow-md hover:bg-gray-500 transition duration-150 ease-in-out">
                    <span id="soundStatus">Sound: ON</span>
                </button>

                <!-- Debug Toggle Button (Mirroring the control panel one) -->
                <button id="modalDebugToggle" class="w-full px-4 py-3 bg-red-700 text-white font-medium rounded-lg shadow-md hover:bg-red-600 transition duration-150 ease-in-out">
                    Toggle Debug Stats
                </button>
                
                <!-- Reset Game Button -->
                <button id="resetGameButton" class="w-full px-4 py-3 bg-yellow-600 text-white font-bold rounded-lg shadow-md hover:bg-yellow-500 transition duration-150 ease-in-out">
                    Reset Game (New Start)
                </button>

            </div>
            
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // --- Tone.js Setup for Sound Effects ---
            const masterVolume = new Tone.Volume(-10).toDestination();

            const synths = {
                BASE: new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.1 } }).connect(masterVolume),
                POWER: new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: "exponential" } }).connect(masterVolume),
                RAPID: new Tone.PluckSynth({ attackNoise: 1, dampening: 4000, resonance: 0.7 }).connect(masterVolume),
                FROST: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).connect(masterVolume),
                MORTAR: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.01, release: 0.1 } }).connect(masterVolume),
                LIGHTNING: new Tone.AMSynth({ harmonicity: 3.99, detune: 0, oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 }, modulation: { type: "square" }, modulationEnvelope: { attack: 0.01, decay: 0.5, sustain: 1, release: 0.5 } }).connect(masterVolume),
                RAILGUN: new Tone.FMSynth({ harmonicity: 3, modulationIndex: 10, envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.1 }, modulationEnvelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.2 } }).connect(masterVolume),
                COIN: new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.1 } }).connect(masterVolume)
            };
            
            // --- Game Configuration ---
            const TILE_SIZE = 20; 
            const PROJECTILE_SPEED_BASE = 300; 
            const TOWER_RADIUS_VALUE = 15; 
            const SCALING_GRACE_LIMIT = 3; // First 3 towers of a type have no scaling cost
            
            const SOUND_COOLDOWN_SECONDS = 0.05; 
            
            const LEVEL_PATHS = {
                LEVEL_1: {
                    name: "Level 1: Winding Road",
                    path: [ { x: 0, y: 100 }, { x: 250, y: 100 }, { x: 250, y: 400 }, { x: 100, y: 400 }, { x: 100, y: 200 }, { x: 450, y: 200 }, { x: 450, y: 500 }, { x: 700, y: 500 }, { x: 700, y: 100 }, { x: 800, y: 100 } ],
                    NON_BUILDABLE_ZONES: [] 
                },
                LEVEL_2: {
                    name: "Level 2: Central Spiral",
                    path: [ { x: 0, y: 300 }, { x: 700, y: 300 }, { x: 700, y: 100 }, { x: 100, y: 100 }, { x: 100, y: 500 }, { x: 600, y: 500 }, { x: 600, y: 200 }, { x: 200, y: 200 }, { x: 200, y: 400 }, { x: 450, y: 400 }, { x: 450, y: 250 }, { x: 800, y: 250 } ],
                    NON_BUILDABLE_ZONES: []
                },
                LEVEL_3: {
                    name: "Level 3: Intersections",
                    path: [ { x: 100, y: 0 }, { x: 100, y: 250 }, { x: 700, y: 250 }, { x: 700, y: 100 }, { x: 200, y: 100 }, { x: 200, y: 450 }, { x: 700, y: 450 }, { x: 700, y: 350 }, { x: 100, y: 350 }, { x: 100, y: 600 } ],
                    NON_BUILDABLE_ZONES: []
                }
            };
            
            const TOWER_CONFIGS = {
                BASE: { name: 'Base Turret', cost: 60, range: 170, fireRate: 1.0, damage: 1.8, color: '#3b82f6', description: 'Standard unit. Good range and decent power.', upgradeCost: 40, sound: 'BASE' },
                POWER: { name: 'Power Cannon', cost: 185, range: 200, fireRate: 1.0, damage: 2, color: '#f97316', description: 'High damage and range for tanks.', upgradeCost: 150, sound: 'POWER' },
                RAPID: { name: 'Rapid Gun', cost: 130, range: 140, fireRate: 0.25, damage: 1, color: '#ec4899', description: 'Shreds swarms at close range.', upgradeCost: 110, sound: 'RAPID' },
                FROST: { name: 'Frost Tower', cost: 110, range: 130, fireRate: 1.5, damage: 0.1, color: '#38bdf8', description: 'Slows enemies on hit.', projectileType: 'FROST', upgradeCost: 90, sound: 'FROST' },
                MORTAR: { name: 'Mortar', cost: 200, range: 250, fireRate: 4.0, damage: 15, color: '#84cc16', description: 'Deals splash damage.', projectileType: 'SPLASH', splashRadius: 45, upgradeCost: 170, sound: 'MORTAR' },
                LIGHTNING: { name: 'Lightning', cost: 250, range: 160, fireRate: 1.2, damage: 8, color: '#a855f7', description: 'Chains to 3 nearby enemies.', projectileType: 'LIGHTNING', chainTargets: 3, chainRadius: 100, chainDamageFalloff: 0.5, upgradeCost: 200, sound: 'LIGHTNING' },
                RAILGUN: { name: 'Railgun', cost: 450, range: 9999, fireRate: 6.0, damage: 100, color: '#fde047', description: 'Global range, hits strongest enemy.', projectileType: 'RAILGUN', upgradeCost: 400, sound: 'RAILGUN' },
                BUFF: { name: 'Buff Tower', cost: 275, range: 100, fireRate: 0, damage: 0, color: '#fcd34d', description: 'Aura: +20% DMG to nearby towers.', projectileType: 'AURA', buffAmount: 0.20, upgradeCost: 220 },
                BANK: { name: 'Bank', cost: 1200, range: 0, fireRate: 5.0, damage: 0, color: '#16a34a', description: 'Spawns clickable coins during waves.', projectileType: 'NONE', coinValue: 40, upgradeCost: 800 }
            };

            let path = []; 
            const pathColor = "#404040"; 
            
            let nonBuildableZones = [];

            const ENEMY_TYPES = {
                RED: { health: 1, speed: 60, value: 4, color: '#ef4444' },     
                BLUE: { health: 15, speed: 54, value: 7, color: '#3b82f6' },   
                GREEN: { health: 30, speed: 48, value: 10, color: '#22c55e' },  
                FAST: { health: 10, speed: 108, value: 8, color: '#facc15' },   
                PURPLE: { health: 80, speed: 36, value: 18, color: '#a855f7' },  
                GOLD: { health: 20, speed: 72, value: 30, color: '#fcd34d' }, 
                BOSS: { health: 250, speed: 30, value: 45, color: '#ec4899' }  
            };
            
            const PRIORITY_TYPES = [ { name: 'FIRST', desc: 'Closest to exit' }, { name: 'LAST', desc: 'Closest to entry' }, { name: 'STRONGEST', desc: 'Highest health' }, { name: 'WEAKEST', desc: 'Lowest health' }, { name: 'RANDOM', desc: 'Random in range' }, ];

            const WAVE_DATA = [ null, { total: 15, composition: [{ type: ENEMY_TYPES.RED, count: 15 }], interval: 400 }, { total: 20, composition: [{ type: ENEMY_TYPES.RED, count: 20 }], interval: 400 }, { total: 15, composition: [{ type: ENEMY_TYPES.RED, count: 10 }, { type: ENEMY_TYPES.BLUE, count: 5 }], interval: 380 }, { total: 25, composition: [{ type: ENEMY_TYPES.RED, count: 15 }, { type: ENEMY_TYPES.BLUE, count: 10 }], interval: 350 }, { total: 20, composition: [{ type: ENEMY_TYPES.RED, count: 10 }, { type: ENEMY_TYPES.BLUE, count: 5 }, { type: ENEMY_TYPES.FAST, count: 5 }], interval: 350 }, { total: 30, composition: [{ type: ENEMY_TYPES.BLUE, count: 15 }, { type: ENEMY_TYPES.FAST, count: 15 }], interval: 320 }, { total: 35, composition: [{ type: ENEMY_TYPES.BLUE, count: 20 }, { type: ENEMY_TYPES.FAST, count: 10 }, { type: ENEMY_TYPES.GREEN, count: 5 }], interval: 300 }, { total: 40, composition: [{ type: ENEMY_TYPES.BLUE, count: 10 }, { type: ENEMY_TYPES.GREEN, count: 10 }, { type: ENEMY_TYPES.GOLD, count: 20 }], interval: 280 }, { total: 40, composition: [{ type: ENEMY_TYPES.RED, count: 20 }, { type: ENEMY_TYPES.BLUE, count: 10 }, { type: ENEMY_TYPES.GREEN, count: 10 }], interval: 280 }, { total: 45, composition: [{ type: ENEMY_TYPES.FAST, count: 20 }, { type: ENEMY_TYPES.GREEN, count: 15 }, { type: ENEMY_TYPES.GOLD, count: 10 }], interval: 250 }, { total: 40, composition: [{ type: ENEMY_TYPES.RED, count: 20 }, { type: ENEMY_TYPES.PURPLE, count: 5 }, { type: ENEMY_TYPES.GREEN, count: 15 }], interval: 300 }, { total: 50, composition: [{ type: ENEMY_TYPES.PURPLE, count: 5 }, { type: ENEMY_TYPES.FAST, count: 45 }], interval: 250 }, { total: 55, composition: [{ type: ENEMY_TYPES.BLUE, count: 10 }, { type: ENEMY_TYPES.GREEN, count: 10 }, { type: ENEMY_TYPES.GOLD, count: 35 }], interval: 220 }, { total: 60, composition: [{ type: ENEMY_TYPES.PURPLE, count: 10 }, { type: ENEMY_TYPES.FAST, count: 50 }], interval: 200 }, { total: 1, composition: [{ type: ENEMY_TYPES.BOSS, count: 1 }], interval: 1000 }, ];

            let money = 250; 
            let lives = 50;  
            let wave = 0;
            let gameStarted = false;
            let placingTower = false; 
            let continuousPlacement = false; 
            let enemies = [];
            let towers = [];
            let projectiles = [];
            let visualEffects = []; 
            let collectibles = [];
            let frame = 0; 
            let wavePauseTimer = 0; 
            let spawnQueue = []; 
            let currentWaveInterval = 0; 
            let waveInProgress = false;
            let freePlacement = false; 
            let gameSpeedMultiplier = 1;
            let selectedTower = null;
            let debugMode = false;
            let soundEnabled = true; 
            let lastFrameTime = 0; 
            let currentLevelId = null; 
            
            let selectedTowerType = 'BASE';
            
            let lastSnappedCoord = {x: -1, y: -1}; 

            let lastHitSoundTime = 0; 
            
            function playTowerSound(soundKey, note = "C4") {
                if (!soundEnabled || !soundKey || !synths[soundKey]) return;
                
                if (Tone.context.state !== 'running') return; 

                if ((lastFrameTime - lastHitSoundTime) / 1000.0 < SOUND_COOLDOWN_SECONDS) { 
                    return; 
                }
                
                const synth = synths[soundKey];
                if (soundKey === 'BASE') synth.triggerAttackRelease("C4", "8n");
                else if (soundKey === 'RAPID') synth.triggerAttackRelease("C5", "16n");
                else if (soundKey === 'POWER') synth.triggerAttackRelease("C2", "8n");
                else if (soundKey === 'FROST' || soundKey === 'MORTAR') synth.triggerAttackRelease("8n");
                else if (soundKey === 'LIGHTNING') synth.triggerAttackRelease("G5", "16n");
                else if (soundKey === 'RAILGUN') synth.triggerAttackRelease("G5", "16n", Tone.now(), 0.05);
                else if (soundKey === 'COIN') synth.triggerAttackRelease(note, "16n");

                lastHitSoundTime = lastFrameTime; 
            }

            const moneyEl = document.getElementById('money');
            const livesEl = document.getElementById('lives');
            const waveEl = document.getElementById('wave');
            const startButton = document.getElementById('startButton');
            const continuousPlacementButton = document.getElementById('continuousPlacementButton');
            const messageBox = document.getElementById('messageBox');
            const freePlacementCheckbox = document.getElementById('freePlacementCheckbox');
            const mainMenuContainer = document.getElementById('mainMenuContainer');
            const gameUiContainer = document.getElementById('gameUiContainer');
            
            const menuStartButton = document.getElementById('menuStartButton');
            const levelSelectorEl = document.getElementById('levelSelector');
            const levelMessage = document.getElementById('levelMessage');

            const towerModal = document.getElementById('towerModal');
            const modalClose = document.querySelector('.modal-close');
            const priorityOptions = document.getElementById('priorityOptions');
            const statDamage = document.getElementById('statDamage');
            const statRange = document.getElementById('statRange');
            const statFireRate = document.getElementById('statFireRate');
            
            const optionsButton = document.getElementById('optionsButton');
            const optionsModal = document.getElementById('optionsModal');
            const optionsModalClose = document.getElementById('optionsModalClose');

            const speedButtons = [ document.getElementById('speed1x'), document.getElementById('speed2x'), document.getElementById('speed4x') ];
            const debugMenuEl = document.getElementById('debugMenu');
            const debugToggleBtn = document.getElementById('debugToggleBtn'); 

            const towerPurchaseButtonsContainer = document.getElementById('towerPurchaseButtons');

            const toggleSoundButton = document.getElementById('toggleSoundButton');
            const soundStatusEl = document.getElementById('soundStatus');
            const resetGameButton = document.getElementById('resetGameButton');
            const modalDebugToggle = document.getElementById('modalDebugToggle'); 
            const volumeSlider = document.getElementById('volumeSlider');

            function toggleSound() {
                soundEnabled = !soundEnabled;
                Tone.Destination.mute = !soundEnabled;
                const statusText = soundEnabled ? 'ON' : 'OFF';
                soundStatusEl.textContent = `Sound: ${statusText}`;
                toggleSoundButton.classList.toggle('bg-gray-600', soundEnabled);
                toggleSoundButton.classList.toggle('bg-red-500', !soundEnabled);
                showMessage(`Sound is now ${soundEnabled ? 'enabled' : 'disabled'}`, 'blue');
            }

            function handleDebugToggle() {
                debugMode = !debugMode;
                debugMenuEl.classList.toggle('hidden', !debugMode);
                debugToggleBtn.textContent = debugMode ? 'Hide Debug' : 'Toggle Debug';
                modalDebugToggle.textContent = debugMode ? 'Debug: ON' : 'Debug: OFF';
                modalDebugToggle.classList.toggle('bg-red-700', !debugMode);
                modalDebugToggle.classList.toggle('bg-green-700', debugMode);
            }

            function upgradeTower(tower, cost) {
                if (money < cost) {
                    showMessage('Not enough money for this upgrade!', 'red');
                    return;
                }
                if (tower.level >= tower.maxLevel) {
                    showMessage('Tower is already max level!', 'blue');
                    return;
                }

                money -= cost;
                tower.level++;
                tower.cost += cost; 

                tower.damage = parseFloat((tower.damage * 1.5).toFixed(2)); 
                tower.range = Math.floor(tower.range * 1.1); 
                tower.fireRate = parseFloat((tower.fireRate * 0.9).toFixed(2)); 

                if (tower.type === 'FROST') {
                    tower.slowAmount = parseFloat((tower.slowAmount + 0.05).toFixed(2)); 
                    tower.slowDuration = parseFloat((tower.slowDuration + 0.5).toFixed(2)); 
                }
                if (tower.type === 'MORTAR') {
                    tower.splashRadius = Math.floor(tower.splashRadius * 1.2); 
                }
                if (tower.type === 'LIGHTNING') {
                    tower.chainTargets += 1; 
                    tower.chainRadius = Math.floor(tower.chainRadius * 1.1); 
                }
                if (tower.type === 'RAILGUN') {
                    tower.damage = parseFloat((tower.damage * 1.8).toFixed(2)); 
                    tower.fireRate = parseFloat((tower.fireRate * 0.95).toFixed(2)); 
                }
                if (tower.type === 'BUFF') {
                    tower.range = Math.floor(tower.range * 1.2); 
                    tower.buffAmount = parseFloat((tower.buffAmount + 0.05).toFixed(2)); 
                }
                if (tower.type === 'BANK') {
                    tower.coinValue = Math.floor(tower.coinValue * 1.5);
                    tower.fireRate = parseFloat((tower.fireRate * 0.85).toFixed(2));
                }
                
                moneyEl.textContent = money;
                showMessage(`Upgraded ${TOWER_CONFIGS[tower.type].name} to Level ${tower.level}!`, 'green');
                openTowerModal(tower); 
            }

            class Tower {
                constructor(x, y, type = 'BASE') {
                    const config = TOWER_CONFIGS[type];
                    this.x = x;
                    this.y = y;
                    this.type = type;
                    this.range = config.range;
                    this.fireRate = config.fireRate;
                    this.damage = config.damage;
                    this.cost = getTowerCost(type); // DYNAMIC COST
                    this.color = config.color; 
                    this.radius = TOWER_RADIUS_VALUE; 
                    this.fireCooldown = 0;
                    this.priority = 'FIRST';
                    
                    this.level = 1;
                    this.maxLevel = 3;
                    this.projectileType = config.projectileType || 'NORMAL';
                    this.splashRadius = config.splashRadius || 0;
                    this.sound = config.sound || null; 
                    
                    if (this.type === 'FROST') {
                        this.slowAmount = 0.5;
                        this.slowDuration = 2.0;
                    }
                    if (this.type === 'LIGHTNING') {
                        this.chainTargets = config.chainTargets;
                        this.chainRadius = config.chainRadius;
                        this.chainDamageFalloff = config.chainDamageFalloff;
                    }
                    if (this.type === 'RAILGUN') {
                        this.priority = 'STRONGEST'; 
                    }
                    if (this.type === 'BUFF') {
                        this.buffAmount = config.buffAmount;
                    }
                    if (this.type === 'BANK') {
                        this.coinValue = config.coinValue;
                    }

                    this.damageBuff = 0; 
                }
                
                resetBuffs() {
                    this.damageBuff = 0;
                }

                applyBuff() {
                    if (this.type !== 'BUFF') return;
                    
                    for (const otherTower of towers) {
                        if (otherTower === this) continue; 
                        
                        const dx = otherTower.x - this.x;
                        const dy = otherTower.y - this.y;
                        if (Math.sqrt(dx * dx + dy * dy) < this.range) {
                            otherTower.damageBuff += this.buffAmount;
                        }
                    }
                }


                findTarget() {
                    const targetsInRange = [];
                    for (const enemy of enemies) {
                        const dx = enemy.x - this.x;
                        const dy = enemy.y - this.y;
                        if (Math.sqrt(dx * dx + dy * dy) < this.range) {
                            targetsInRange.push(enemy);
                        }
                    }

                    if (targetsInRange.length === 0) return null;

                    switch (this.priority) {
                        case 'FIRST': return targetsInRange.reduce((a, b) => a.pathIndex > b.pathIndex ? a : b);
                        case 'LAST': return targetsInRange.reduce((a, b) => a.pathIndex < b.pathIndex ? a : b);
                        case 'STRONGEST': return targetsInRange.reduce((a, b) => a.health > b.health ? a : b);
                        case 'WEAKEST': return targetsInRange.reduce((a, b) => a.health < b.health ? a : b);
                        case 'RANDOM': default: return targetsInRange[Math.floor(Math.random() * targetsInRange.length)];
                    }
                }

                update(gameDeltaTime) {
                    if (this.projectileType === 'AURA') return; 

                    if (this.fireCooldown > 0) this.fireCooldown -= gameDeltaTime; 

                    if (this.fireCooldown <= 0) {
                        if (this.type === 'BANK' && waveInProgress) {
                            this.spawnCoin();
                            this.fireCooldown = this.fireRate;
                        } else {
                            const target = this.findTarget();
                            if (target) {
                                this.shoot(target);
                                this.fireCooldown = this.fireRate; 
                            }
                        }
                    }
                }

                spawnCoin() {
                    collectibles.push(new Collectible(this.x, this.y, this.coinValue));
                }

                shoot(target) {
                    const finalDamage = this.damage * (1 + this.damageBuff);

                    projectiles.push(new Projectile( this.x, this.y, target, finalDamage, this.projectileType, this.splashRadius, this.slowAmount, this.slowDuration, this.sound, this.chainTargets, this.chainRadius, this.chainDamageFalloff ));
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();

                    if (this.type === 'BUFF') {
                        ctx.strokeStyle = 'rgba(253, 224, 71, 0.3)'; 
                        ctx.fillStyle = 'rgba(253, 224, 71, 0.1)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                    }

                    if (selectedTower === this) {
                        // Pulsing selection effect
                        const pulse = Math.abs(Math.sin(frame * 0.1)) * 4;
                        ctx.strokeStyle = '#facc15';
                        ctx.lineWidth = 3 + pulse / 2;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius + 2 + pulse, 0, Math.PI * 2);
                        ctx.stroke();
                        this.drawRange();
                    }
                    
                    ctx.fillStyle = '#4b5563'; 
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius - 5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Inter'; 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.level, this.x, this.y - 1); 

                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 10px Inter'; 
                    ctx.textAlign = 'center';
                    ctx.fillText(this.priority.charAt(0), this.x, this.y + 10);
                }

                drawRange() {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; 
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            class Enemy {
                constructor(type, healthMultiplier = 1, isElite = null) {
                    this.x = path[0].x; 
                    this.y = path[0].y;
                    this.pathIndex = 0;
                    this.baseSpeed = type.speed; 
                    this.speed = this.baseSpeed; 
                    this.maxHealth = Math.ceil(type.health * healthMultiplier);
                    this.health = this.maxHealth;
                    this.value = type.value; 
                    this.radius = this.maxHealth > 100 ? 18 : (this.maxHealth > 10 ? 14 : 10);
                    this.color = type.color;
                    this.isBoss = type.color === ENEMY_TYPES.BOSS.color;
                    this.slowTimer = 0;
                    
                    this.isElite = !!isElite;
                    this.eliteType = isElite;
                    this.shield = 0;
                    this.maxShield = 0;
                    this.shieldRegenTimer = 0;

                    if (this.isElite) {
                        this.radius += 2;
                        this.value *= 2;
                        if (this.eliteType === 'SHIELDED') {
                            this.maxShield = Math.ceil(this.maxHealth * 0.75);
                            this.shield = this.maxShield;
                        }
                    }
                }

                applySlow(amount, duration) {
                    this.speed = this.baseSpeed * (1 - amount); 
                    this.slowTimer = Math.max(this.slowTimer, duration); 
                }

                takeDamage(amount) {
                    this.shieldRegenTimer = 3.0; // Reset regen timer on hit

                    if (this.eliteType === 'SHIELDED' && this.shield > 0) {
                        this.shield -= amount;
                        if (this.shield < 0) {
                            this.health += this.shield; // Remainder damage hits health
                            this.shield = 0;
                        }
                    } else {
                        this.health -= amount;
                    }

                    if (this.health <= 0) {
                        money += this.value;
                        moneyEl.textContent = money;
                    }
                }

                move(gameDeltaTime) {
                    // Handle Elite logic
                    if (this.isElite) {
                        if (this.eliteType === 'SHIELDED') {
                            if (this.shield < this.maxShield) {
                                this.shieldRegenTimer -= gameDeltaTime;
                                if (this.shieldRegenTimer <= 0) {
                                    this.shield = Math.min(this.maxShield, this.shield + (this.maxShield * 0.1) * gameDeltaTime);
                                }
                            }
                        } else if (this.eliteType === 'AURA') {
                            for (const otherEnemy of enemies) {
                                if (otherEnemy === this || otherEnemy.isElite) continue;
                                const dx = otherEnemy.x - this.x;
                                const dy = otherEnemy.y - this.y;
                                if (Math.sqrt(dx * dx + dy * dy) < 60) { // Aura radius
                                    otherEnemy.speed = otherEnemy.baseSpeed * 1.5;
                                }
                            }
                        }
                    }

                    if (this.slowTimer > 0) {
                        this.slowTimer -= gameDeltaTime;
                        if (this.slowTimer <= 0) this.speed = this.baseSpeed; 
                    } else {
                        // Reset speed if not slowed and not in aura
                        this.speed = this.baseSpeed;
                    }

                    const movementDistance = this.speed * gameDeltaTime; 
                    
                    if (this.pathIndex >= path.length - 1) {
                        lives -= this.isBoss ? 5 : 1; 
                        livesEl.textContent = lives;
                        this.health = 0; 
                        if (lives <= 0) endGame(false);
                        return;
                    }

                    const target = path[this.pathIndex + 1];
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < movementDistance) {
                        this.x = target.x;
                        this.y = target.y;
                        this.pathIndex++;
                    } else {
                        this.x += (dx / dist) * movementDistance;
                        this.y += (dy / dist) * movementDistance;
                    }
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();

                    // Elite Visuals
                    if (this.isElite) {
                        if (this.eliteType === 'AURA') {
                            ctx.strokeStyle = 'rgba(250, 204, 21, 0.7)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, 60, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                    
                    if (this.slowTimer > 0) {
                        ctx.strokeStyle = '#38bdf8'; 
                        ctx.lineWidth = 3;
                        ctx.stroke();
                    }

                    if (this.isBoss || this.color === ENEMY_TYPES.PURPLE.color) {
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                    // Health and Shield Bars
                    const barWidth = this.radius * 2 + 5;
                    const barY = this.y - this.radius - 12;

                    if (this.health < this.maxHealth) {
                        ctx.fillStyle = '#171717'; 
                        ctx.fillRect(this.x - barWidth / 2, barY, barWidth, 5);
                        const healthRatio = this.health / this.maxHealth;
                        ctx.fillStyle = healthRatio > 0.5 ? '#22c55e' : (healthRatio > 0.2 ? '#facc15' : '#ef4444'); 
                        ctx.fillRect(this.x - barWidth / 2, barY, barWidth * healthRatio, 5);
                    }
                    if (this.eliteType === 'SHIELDED' && this.maxShield > 0) {
                        const shieldY = (this.health < this.maxHealth) ? barY - 6 : barY;
                        ctx.fillStyle = '#374151';
                        ctx.fillRect(this.x - barWidth / 2, shieldY, barWidth, 4);
                        const shieldRatio = this.shield / this.maxShield;
                        ctx.fillStyle = '#e5e7eb';
                        ctx.fillRect(this.x - barWidth / 2, shieldY, barWidth * shieldRatio, 4);
                    }
                }
            }

            class Projectile {
                constructor(x, y, target, damage, type = 'NORMAL', splashRadius = 0, slowAmount = 0.5, slowDuration = 2.0, sound = 'BASE', chainTargets = 0, chainRadius = 0, chainFalloff = 0.5) {
                    this.x = x;
                    this.y = y;
                    this.target = target;
                    this.damage = damage;
                    this.speed = (type === 'RAILGUN') ? 10000 : PROJECTILE_SPEED_BASE; 
                    this.radius = (type === 'RAILGUN') ? 5 : 3;
                    this.type = type;
                    this.splashRadius = splashRadius;
                    this.slowDuration = slowDuration; 
                    this.slowAmount = slowAmount;   
                    this.sound = sound; 
                    this.color = type === 'FROST' ? '#38bdf8' : (type === 'SPLASH' ? '#84cc16' : (type === 'LIGHTNING' ? '#d8b4fe' : (type === 'RAILGUN' ? '#fde047' : '#f1f5f9')));
                
                    this.chainTargets = chainTargets;
                    this.chainRadius = chainRadius;
                    this.chainFalloff = chainFalloff;
                }
                
                handleHit() {
                    playTowerSound(this.sound); 
                    
                    if (this.target.health <= 0 && this.type !== 'SPLASH') return; 

                    if (this.type === 'SPLASH') {
                        for (const enemy of enemies) {
                            const dx = enemy.x - this.target.x; 
                            const dy = enemy.y - this.target.y;
                            if (Math.sqrt(dx * dx + dy * dy) < this.splashRadius) enemy.takeDamage(this.damage);
                        }
                    } else if (this.type === 'FROST') {
                        this.target.takeDamage(this.damage); 
                        this.target.applySlow(this.slowAmount, this.slowDuration);
                    } else {
                        this.target.takeDamage(this.damage);
                    }
                    
                    if (this.type === 'LIGHTNING') {
                        let currentTarget = this.target;
                        let chainedEnemies = [currentTarget]; 
                        let chainDamage = this.damage * this.chainFalloff;

                        for (let i = 0; i < this.chainTargets; i++) {
                            let nextTarget = null;
                            let minDistance = this.chainRadius;

                            for (const enemy of enemies) {
                                if (enemy.health > 0 && !chainedEnemies.includes(enemy)) {
                                    const dx = enemy.x - currentTarget.x;
                                    const dy = enemy.y - currentTarget.y;
                                    const dist = Math.sqrt(dx * dx + dy * dy);
                                    
                                    if (dist < minDistance) {
                                        minDistance = dist;
                                        nextTarget = enemy;
                                    }
                                }
                            }

                            if (nextTarget) {
                                nextTarget.takeDamage(chainDamage);
                                chainedEnemies.push(nextTarget);
                                
                                visualEffects.push({ type: 'LIGHTNING', startX: currentTarget.x, startY: currentTarget.y, endX: nextTarget.x, endY: nextTarget.y, timer: 0.1 });
                                
                                playTowerSound(this.sound);
                                
                                currentTarget = nextTarget;
                            } else {
                                break; 
                            }
                        }
                    }
                }

                move(gameDeltaTime) {
                    const movementDistance = this.speed * gameDeltaTime;
                    
                    if (this.target.health <= 0 && this.type !== 'SPLASH') return true; 
                    
                    const targetX = this.target.x;
                    const targetY = this.target.y;

                    const dx = targetX - this.x;
                    const dy = targetY - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < movementDistance) {
                        this.handleHit(); 
                        return true; 
                    } else {
                        this.x += (dx / dist) * movementDistance;
                        this.y += (dy / dist) * movementDistance;
                    }
                    return false;
                }

                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            class Collectible {
                constructor(x, y, value) {
                    this.x = x;
                    this.y = y;
                    this.value = value;
                    this.radius = 10;
                    this.lifespan = 4.0; // 4 seconds to collect
                    this.vx = (Math.random() - 0.5) * 80; // Horizontal pop
                    this.vy = -120; // Vertical pop
                    this.gravity = 250;
                }

                update(gameDeltaTime) {
                    this.lifespan -= gameDeltaTime;
                    this.vy += this.gravity * gameDeltaTime;
                    this.x += this.vx * gameDeltaTime;
                    this.y += this.vy * gameDeltaTime;
                }

                draw() {
                    const alpha = Math.max(0, this.lifespan / 2.0); // Fade out
                    ctx.globalAlpha = alpha;

                    ctx.fillStyle = '#fde047';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.fillStyle = '#ca8a04';
                    ctx.font = 'bold 12px Inter';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('$', this.x, this.y + 1);
                    
                    ctx.globalAlpha = 1.0;
                }
            }

            function getTowerCost(type) {
                const config = TOWER_CONFIGS[type];
                const count = towers.filter(t => t.type === type).length;
                if (count < SCALING_GRACE_LIMIT) {
                    return config.cost;
                }
                const scaledCount = count - SCALING_GRACE_LIMIT;
                const cost = Math.floor(config.cost * (1 + scaledCount * 0.08)); // 8% cost increase per tower after grace
                return cost;
            }

            function renderTowerPurchaseButtons() {
                towerPurchaseButtonsContainer.innerHTML = '';
                
                Object.entries(TOWER_CONFIGS).forEach(([key, config]) => {
                    const button = document.createElement('button');
                    button.id = `buyTower-${key}`;
                    const currentCost = getTowerCost(key);
                    button.textContent = `${config.name} ($${currentCost})`;
                    button.className = 'btn-tower flex flex-col items-center justify-center h-16 text-center';
                    
                    if (config.projectileType === 'LIGHTNING' || config.projectileType === 'RAILGUN' || config.projectileType === 'AURA' || config.projectileType === 'NONE') {
                         button.classList.add(`style-${key.replace('AMPLIFIER', 'BUFF')}`);
                    }
                    
                    const costSpan = document.createElement('span');
                    costSpan.className = 'text-xs opacity-75';
                    costSpan.textContent = config.description;

                    button.appendChild(costSpan);

                    button.addEventListener('click', () => {
                        togglePlacementMode(key, 'single');
                    });
                    
                    if (key === selectedTowerType) button.classList.add('selected');

                    towerPurchaseButtonsContainer.appendChild(button);
                });
            }

            function updatePlacementButtonStyles() {
                Object.keys(TOWER_CONFIGS).forEach(key => {
                    const button = document.getElementById(`buyTower-${key}`);
                    if (button) {
                        button.classList.remove('selected');
                        if ((placingTower && selectedTowerType === key) || (continuousPlacement && selectedTowerType === key)) {
                            button.classList.add('selected');
                        }
                    }
                });
                continuousPlacementButton.classList.toggle('active', continuousPlacement);
            }


            function drawGrid() {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 0.5;

                for (let x = 0; x <= canvas.width; x += TILE_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                }

                for (let y = 0; y <= canvas.height; y += TILE_SIZE) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                    ctx.stroke();
                }
            }
            
            function drawPath() {
                if (path.length === 0) return; 

                ctx.strokeStyle = pathColor;
                ctx.lineWidth = TILE_SIZE; 
                ctx.lineCap = "round";
                ctx.lineJoin = "round";
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
                ctx.stroke();
                
                ctx.strokeStyle = "#525252"; 
                ctx.lineWidth = TILE_SIZE - 4; 
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) ctx.lineTo(path[i].x, path[i].y);
                ctx.stroke();
            }

            function isOnPath(x, y) {
                if (path.length === 0) return false;

                const halfPathWidth = TILE_SIZE / 2; 
                for (let i = 0; i < path.length - 1; i++) {
                    const p1 = path[i];
                    const p2 = path[i + 1];

                    const minX = Math.min(p1.x, p2.x) - halfPathWidth;
                    const maxX = Math.max(p1.x, p2.x) + halfPathWidth;
                    const minY = Math.min(p1.y, p2.y) - halfPathWidth;
                    const maxY = Math.max(p1.y, p2.y) + halfPathWidth;

                    if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                        if (p1.x === p2.x) { 
                            if (Math.abs(x - p1.x) < halfPathWidth) return true;
                        } else if (p1.y === p2.y) { 
                            if (Math.abs(y - p1.y) < halfPathWidth) return true;
                        }
                    }
                }
                return false;
            }
            
            function getWaveComposition(waveNum) {
                let waveData;
                
                const finalHealthMultiplier = waveNum < 10 ? 1.0 : (1 + (waveNum - 9) * 0.12); 

                if (waveNum < WAVE_DATA.length) {
                    waveData = WAVE_DATA[waveNum];
                } else {
                    const totalEnemies = 60 + (waveNum - 15) * 10; 
                    
                    waveData = {
                        total: totalEnemies,
                        composition: [ { type: ENEMY_TYPES.RED, count: Math.ceil(totalEnemies * 0.25) }, { type: ENEMY_TYPES.BLUE, count: Math.ceil(totalEnemies * 0.25) }, { type: ENEMY_TYPES.FAST, count: Math.ceil(totalEnemies * 0.20) }, { type: ENEMY_TYPES.GREEN, count: Math.ceil(totalEnemies * 0.15) }, { type: ENEMY_TYPES.PURPLE, count: Math.ceil(totalEnemies * 0.05) }, { type: ENEMY_TYPES.GOLD, count: Math.ceil(totalEnemies * 0.10) } ].filter(c => c.count > 0),
                        interval: Math.max(120, 200 - (waveNum * 3))
                    };
                }
                
                const finalEnemies = [];
                for (const item of waveData.composition) {
                    for (let i = 0; i < item.count; i++) {
                        const enemyType = item.type;
                        const isBossOrTank = enemyType.color === ENEMY_TYPES.BOSS.color || enemyType.color === ENEMY_TYPES.PURPLE.color;
                        const multiplier = (isBossOrTank && waveNum > 10) ? (finalHealthMultiplier * 1.25) : finalHealthMultiplier;
                        
                        let eliteType = null;
                        if (waveNum >= 20 && !isBossOrTank && Math.random() < 0.1) { // 10% chance for an enemy to be elite
                            eliteType = Math.random() < 0.5 ? 'SHIELDED' : 'AURA';
                        }

                        finalEnemies.push({ type: item.type, healthMultiplier: multiplier, isElite: eliteType });
                    }
                }

                for (let i = finalEnemies.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [finalEnemies[i], finalEnemies[j]] = [finalEnemies[j], finalEnemies[i]];
                }

                return { enemies: finalEnemies, interval: waveData.interval };
            }

            function startNextWave() {
                if (waveInProgress || !gameStarted) return;
                
                if (Tone.context.state !== 'running' && soundEnabled) Tone.start();

                wave++;
                waveEl.textContent = wave;
                
                const waveData = getWaveComposition(wave);
                spawnQueue = waveData.enemies; 
                currentWaveInterval = waveData.interval / 1000.0; 
                spawnCooldown = currentWaveInterval; 
                
                enemiesToSpawn = spawnQueue.length;
                
                waveInProgress = true;
                
                if (wave > 1) showMessage(`Wave ${wave} incoming!`, 'blue');
            }
            
            function updateDebugMenu(deltaTime) { 
                if (!debugMode) return;
                
                const currentFps = 1 / deltaTime; 

                const currentHealthMultiplier = wave < 10 ? 1.0 : (1 + (wave - 9) * 0.12).toFixed(2);
                
                debugMenuEl.innerHTML = ` FPS: <span class="font-bold">${currentFps.toFixed(1)}</span><br> Delta: <span class="font-bold">${deltaTime.toFixed(4)}s</span><br> Level: <span class="font-bold">${currentLevelId}</span><br> Money: $<span class="font-bold">${money}</span><br> Lives: <span class="font-bold">${lives}</span><br> Wave: <span class="font-bold">${wave}</span><br> Health Multiplier: <span class="font-bold">${currentHealthMultiplier}x</span><br> Spawning: <span class="font-bold">${spawnQueue.length}</span><br> Enemies Alive: <span class="font-bold">${enemies.length}</span><br> Projectiles: <span class="font-bold">${projectiles.length}</span><br> Collectibles: <span class="font-bold">${collectibles.length}</span><br> Game Speed: <span class="font-bold">${gameSpeedMultiplier}x</span> `;
            }

            function update(timestamp) {
                if (!gameStarted) {
                    lastFrameTime = timestamp; 
                    requestAnimationFrame(update); 
                    return;
                }
                
                if (lastFrameTime === 0) lastFrameTime = timestamp; 
                
                const deltaTime = (timestamp - lastFrameTime) / 1000.0; 
                lastFrameTime = timestamp; 

                const clampedDeltaTime = Math.min(deltaTime, 0.1); 

                const gameDeltaTime = clampedDeltaTime * gameSpeedMultiplier;

                frame++; 

                updateDebugMenu(deltaTime); 
                
                visualEffects = visualEffects.filter(fx => {
                    fx.timer -= clampedDeltaTime; 
                    return fx.timer > 0;
                });
                
                collectibles.forEach(c => c.update(gameDeltaTime));
                collectibles = collectibles.filter(c => c.lifespan > 0);
                
                towers.forEach(tower => tower.resetBuffs());
                towers.forEach(tower => {
                    if (tower.type === 'BUFF') tower.applyBuff();
                });


                if (waveInProgress && spawnQueue.length === 0 && enemies.length === 0) {
                    waveInProgress = false;
                    wavePauseTimer = 7.0; 
                    startButton.disabled = true; 
                    renderTowerPurchaseButtons(); // Update costs after wave
                    
                    const nextWave = wave + 1;
                    if (nextWave > 1 && nextWave % 5 === 0) {
                        const bonus = 100 + nextWave * 15;
                        money += bonus;
                        moneyEl.textContent = money;
                        showMessage(`Wave ${wave} clear! Bonus for next wave: +$${bonus}`, 'green');
                    } else {
                         showMessage('Wave complete. Planning Phase...', 'blue');
                    }
                }

                if (!waveInProgress && wavePauseTimer > 0) {
                    wavePauseTimer -= gameDeltaTime; 
                    if (wavePauseTimer <= 0) {
                        startButton.disabled = false;
                        showMessage('Ready for the next wave! Click "Start Wave"', 'blue');
                    }
                }

                if (waveInProgress && spawnQueue.length > 0) {
                    spawnCooldown -= gameDeltaTime;
                    if (spawnCooldown <= 0) {
                        const { type, healthMultiplier, isElite } = spawnQueue.shift();
                        enemies.push(new Enemy(type, healthMultiplier, isElite));
                        enemiesToSpawn--; 
                        
                        spawnCooldown = currentWaveInterval; 
                    }
                }

                towers.forEach(tower => tower.update(gameDeltaTime));

                projectiles = projectiles.filter(p => !p.move(gameDeltaTime)); 

                enemies = enemies.filter(enemy => {
                    enemy.move(gameDeltaTime); 
                    return enemy.health > 0; 
                });

                draw();

                requestAnimationFrame(update);
            }

            let lastMouseEvent = {clientX: 0, clientY: 0};
            canvas.addEventListener('mousemove', e => {
                lastMouseEvent = e;
                if(placingTower || continuousPlacement) draw(); 
            });

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid();
                drawPath();
                collectibles.forEach(c => c.draw());
                towers.forEach(tower => tower.draw());
                projectiles.forEach(p => p.draw());
                enemies.forEach(enemy => enemy.draw());
                
                ctx.lineCap = 'round';
                visualEffects.forEach(fx => {
                    if (fx.type === 'LIGHTNING') {
                        ctx.strokeStyle = `rgba(216, 180, 254, ${fx.timer / 0.1})`; 
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(fx.startX, fx.startY);
                        ctx.lineTo( (fx.startX + fx.endX) / 2 + (Math.random() - 0.5) * 15, (fx.startY + fx.endY) / 2 + (Math.random() - 0.5) * 15 );
                        ctx.lineTo(fx.endX, fx.endY);
                        ctx.stroke();
                    }
                });
                ctx.lineCap = 'butt'; 


                if (placingTower || continuousPlacement) { 
                    const { x, y } = getMousePos(canvas, lastMouseEvent); 
                    
                    const config = TOWER_CONFIGS[selectedTowerType];
                    const currentCost = getTowerCost(selectedTowerType);

                    if (x > 0) {
                        let previewX, previewY;
                        if (freePlacement) {
                            previewX = x;
                            previewY = y;
                        } else {
                            const snapped = getSnappedCoords(x, y);
                            previewX = snapped.x;
                            previewY = snapped.y;
                        }
                        
                        const isValid = !isOnPath(previewX, previewY) && !checkTowerCollision(previewX, previewY, true) && (previewX > 0 && previewX < canvas.width && previewY > 0 && previewY < canvas.height) && (money >= currentCost);


                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = isValid ? config.color : 'red';
                        ctx.beginPath();
                        ctx.arc(previewX, previewY, TOWER_RADIUS_VALUE, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; 
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc(previewX, previewY, config.range, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.globalAlpha = 1.0;
                    }
                }
            }
            
            function showMessage(text, color = 'red') {
                messageBox.textContent = text;
                if (color === 'red') messageBox.style.color = '#f87171'; 
                else if (color === 'green') messageBox.style.color = '#4ade80'; 
                else if (color === 'blue') messageBox.style.color = '#60a5fa'; 
                else messageBox.style.color = color;

                setTimeout(() => {
                    if (messageBox.textContent === text) messageBox.textContent = '';
                }, 2000);
            }

            function endGame(win) {
                gameStarted = false;
                
                gameUiContainer.classList.add('hidden');
                mainMenuContainer.classList.remove('hidden');
                
                menuStartButton.textContent = 'Play Again';
                const message = win ? `You won! You beat all ${wave} waves!` : `Game Over! You made it to Wave ${wave}.`;
                document.querySelector('#mainMenuContainer h1').textContent = message;

                currentLevelId = null;
                menuStartButton.disabled = true;
                renderLevelSelector();
            }
            
            function resetGame() {
                money = 200; 
                lives = 50;  
                wave = 0;
                enemies = [];
                towers = [];
                projectiles = [];
                visualEffects = []; 
                collectibles = [];
                frame = 0;
                wavePauseTimer = 0; 
                spawnQueue = [];
                currentWaveInterval = 0;
                waveInProgress = false;
                gameStarted = true;
                placingTower = false;
                continuousPlacement = false; 
                freePlacement = false; 
                gameSpeedMultiplier = 1;
                debugMode = false;
                debugMenuEl.classList.add('hidden');
                lastHitSoundTime = 0; 
                soundEnabled = true; 
                Tone.Destination.mute = false;
                
                selectedTowerType = 'BASE'; 
                lastSnappedCoord = {x: -1, y: -1}; 
                
                if (currentLevelId && LEVEL_PATHS[currentLevelId]) {
                    path = LEVEL_PATHS[currentLevelId].path;
                    nonBuildableZones = LEVEL_PATHS[currentLevelId].NON_BUILDABLE_ZONES || []; 
                } else {
                    path = LEVEL_PATHS.LEVEL_1.path;
                    nonBuildableZones = LEVEL_PATHS.LEVEL_1.NON_BUILDABLE_ZONES || [];
                    currentLevelId = 'LEVEL_1'; 
                }


                document.querySelector('#mainMenuContainer h1').textContent = 'Simple TD';
                moneyEl.textContent = money;
                livesEl.textContent = lives;
                waveEl.textContent = wave;
                continuousPlacementButton.classList.remove('active');
                freePlacementCheckbox.checked = false; 
                selectedTower = null;
                setGameSpeed(1);
                handleDebugToggle(); 
                
                renderTowerPurchaseButtons(); 
                
                startButton.disabled = false; 
                showMessage('Welcome! Build your defenses, then click "Start Wave"!', 'blue');

                draw(); 
                lastFrameTime = 0; 
                requestAnimationFrame(update); 
            }
            
            function getMousePos(canvas, evt) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return { x: (evt.clientX - rect.left) * scaleX, y: (evt.clientY - rect.top) * scaleY };
            }
            
            function getSnappedCoords(x, y) {
                 const snappedX = Math.floor(x / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
                 const snappedY = Math.floor(y / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
                 return {x: snappedX, y: snappedY};
            }

            function findClickedTower(clickX, clickY) {
                for (const tower of towers) {
                    const dx = tower.x - clickX;
                    const dy = tower.y - clickY;
                    if (Math.sqrt(dx * dx + dy * dy) < tower.radius) return tower;
                }
                return null;
            }

            function checkCoinClick(clickX, clickY) {
                for (let i = collectibles.length - 1; i >= 0; i--) {
                    const coin = collectibles[i];
                    const dx = coin.x - clickX;
                    const dy = coin.y - clickY;
                    if (Math.sqrt(dx * dx + dy * dy) < coin.radius) {
                        money += coin.value;
                        moneyEl.textContent = money;
                        playTowerSound('COIN', 'G5');
                        collectibles.splice(i, 1);
                        return true;
                    }
                }
                return false;
            }
            
            function checkTowerCollision(x, y, isContinuous) {
                const minDistanceSq = (TOWER_RADIUS_VALUE * 2) ** 2; 

                for (const tower of towers) {
                    const dx = tower.x - x;
                    const dy = tower.y - y;
                    const distSq = dx * dx + dy * dy;

                    if (distSq < minDistanceSq) { 
                        if (!isContinuous) showMessage('Towers are too close to each other!');
                        return true;
                    }
                }
                return false;
            }

            function attemptTowerPlacement(clickX, clickY, isContinuous = false) {
                
                let placeX, placeY;
                const config = TOWER_CONFIGS[selectedTowerType]; 
                const cost = getTowerCost(selectedTowerType);

                if (freePlacement) {
                    placeX = clickX;
                    placeY = clickY;
                } else {
                    const snapped = getSnappedCoords(clickX, clickY); 
                    placeX = snapped.x;
                    placeY = snapped.y;
                }
                
                if (placeX < TILE_SIZE/2 || placeX > canvas.width - TILE_SIZE/2 || placeY < TILE_SIZE/2 || placeY > canvas.height - TILE_SIZE/2) {
                    if (!isContinuous) showMessage('Cannot place outside the grid bounds!');
                    return false;
                }

                if (isOnPath(placeX, placeY)) {
                    if (!isContinuous) showMessage('Cannot place on path!');
                    return false;
                }

                if (checkTowerCollision(placeX, placeY, isContinuous)) return false;

                if (money < cost) {
                    if (!isContinuous) showMessage(`Not enough money for a ${config.name}! ($${cost})`);
                    return false;
                }
                
                money -= cost;
                moneyEl.textContent = money;
                
                towers.push(new Tower(placeX, placeY, selectedTowerType));
                renderTowerPurchaseButtons(); // Update costs for all towers
                draw(); 
                return true;
            }


            function openTowerModal(tower) {
                selectedTower = tower;
                placingTower = false;
                continuousPlacement = false;
                updatePlacementButtonStyles(); 
                if (optionsModal.style.display === 'block') closeOptionsModal();
                showMessage('');
                
                priorityOptions.innerHTML = ''; 

                document.querySelector('#towerModal .modal-content h2').textContent = `${TOWER_CONFIGS[tower.type].name} Management`;

                statDamage.textContent = tower.damage;
                statRange.textContent = tower.range;
                statFireRate.textContent = tower.fireRate; 
                
                const statsContainer = document.getElementById('towerStats');
                statsContainer.querySelectorAll('.special-stat').forEach(el => el.remove());
                
                if (tower.type === 'FROST') statsContainer.innerHTML += `<p class="special-stat">Slow: <span class="font-bold text-cyan-400">${tower.slowAmount * 100}% for ${tower.slowDuration}s</span></p>`;
                if (tower.type === 'MORTAR') statsContainer.innerHTML += `<p class="special-stat">Splash Radius: <span class="font-bold text-lime-400">${tower.splashRadius}px</span></p>`;
                if (tower.type === 'LIGHTNING') statsContainer.innerHTML += `<p class="special-stat">Chain: <span class="font-bold text-purple-400">${tower.chainTargets} targets</span></p>`;
                if (tower.type === 'RAILGUN') statsContainer.innerHTML += `<p class="special-stat">Target: <span class="font-bold text-yellow-300">STRONGEST</span></p>`;
                if (tower.type === 'BUFF') {
                    statsContainer.innerHTML += `<p class="special-stat">Aura Buff: <span class="font-bold text-yellow-300">+${tower.buffAmount * 100}% DMG</span></p>`;
                    statsContainer.innerHTML += `<p class="special-stat">Aura Radius: <span class="font-bold text-blue-400">${tower.range}px</span></p>`;
                }
                if (tower.type === 'BANK') statsContainer.innerHTML += `<p class="special-stat">Coin Value: <span class="font-bold text-green-400">$${tower.coinValue}</span></p>`;


                const levelDisplay = document.createElement('p');
                levelDisplay.innerHTML = `Level: <span class="font-bold text-yellow-400">${tower.level} / ${tower.maxLevel}</span>`;
                levelDisplay.className = "text-center text-lg mb-2";
                priorityOptions.appendChild(levelDisplay);

                if (tower.level < tower.maxLevel) {
                    const baseUpgradeCost = TOWER_CONFIGS[tower.type].upgradeCost;
                    const upgradeCost = tower.level * baseUpgradeCost; 
                    
                    const upgradeButton = document.createElement('button');
                    upgradeButton.textContent = `Upgrade to Lvl ${tower.level + 1} ($${upgradeCost})`;
                    upgradeButton.className = 'btn-upgrade';
                    
                    if (money < upgradeCost) {
                        upgradeButton.disabled = true;
                        upgradeButton.title = "Not enough money!";
                    }
                    
                    upgradeButton.onclick = () => upgradeTower(tower, upgradeCost);
                    priorityOptions.appendChild(upgradeButton);
                } else {
                    const maxLevelText = document.createElement('p');
                    maxLevelText.textContent = "Max Level Reached";
                    maxLevelText.className = "text-center font-bold text-green-400";
                    priorityOptions.appendChild(maxLevelText);
                }


                const sellValue = Math.floor(tower.cost / 2); 
                const sellButton = document.createElement('button');
                sellButton.textContent = `Sell Tower ($${sellValue})`;
                sellButton.className = 'btn-sell mt-2'; 
                sellButton.onclick = () => sellTower(tower, sellValue);
                priorityOptions.appendChild(sellButton); 

                const priorityHeader = document.createElement('h3');
                priorityHeader.textContent = 'Target Priority:';
                priorityHeader.className = 'text-lg font-semibold mb-2 mt-4 border-t border-gray-600 pt-3';
                priorityOptions.appendChild(priorityHeader);

                const priorityGrid = document.createElement('div');
                priorityGrid.className = 'grid grid-cols-2 gap-2';
                
                const canChangePriority = tower.type !== 'RAILGUN' && tower.type !== 'BUFF' && tower.type !== 'BANK';

                PRIORITY_TYPES.forEach(p => {
                    const button = document.createElement('button');
                    button.textContent = p.name;
                    button.title = p.desc;
                    button.className = `p-2 rounded-lg text-sm transition duration-150 ease-in-out font-semibold ${ tower.priority === p.name ? 'bg-purple-600 text-white shadow-lg' : 'bg-gray-700 text-gray-300 hover:bg-gray-600' }`;
                    
                    if (!canChangePriority) {
                        button.disabled = true;
                        button.className += ' opacity-50 cursor-not-allowed';
                        if (tower.type === 'RAILGUN' && p.name === 'STRONGEST') {
                            button.className = 'p-2 rounded-lg text-sm font-semibold bg-yellow-600 text-white shadow-lg opacity-100';
                        }
                    }

                    button.onclick = () => setTowerPriority(p.name);
                    priorityGrid.appendChild(button);
                });
                
                priorityOptions.appendChild(priorityGrid);


                towerModal.style.display = 'block';
            }
            
            function closeTowerModal() {
                towerModal.style.display = 'none';
                selectedTower = null;
                draw();
            }

            function setTowerPriority(priority) {
                if (selectedTower) {
                    selectedTower.priority = priority;
                    openTowerModal(selectedTower); 
                    showMessage(`Tower priority set to ${priority}`, 'blue');
                }
            }
            
            function sellTower(tower, value) {
                towers = towers.filter(t => t !== tower);
                money += value;
                moneyEl.textContent = money;
                renderTowerPurchaseButtons(); // Update costs after selling
                closeTowerModal();
                showMessage(`Sold ${TOWER_CONFIGS[tower.type].name} for $${value}`, 'green');
            }
            
            function openOptionsModal() {
                if (towerModal.style.display === 'block') closeTowerModal();
                placingTower = false;
                continuousPlacement = false;
                updatePlacementButtonStyles();
                showMessage('');

                const statusText = soundEnabled ? 'ON' : 'OFF';
                soundStatusEl.textContent = `Sound: ${statusText}`;
                toggleSoundButton.classList.toggle('bg-gray-600', soundEnabled);
                toggleSoundButton.classList.toggle('bg-red-500', !soundEnabled);

                modalDebugToggle.textContent = debugMode ? 'Debug: ON' : 'Debug: OFF';
                modalDebugToggle.classList.toggle('bg-red-700', !debugMode);
                modalDebugToggle.classList.toggle('bg-green-700', debugMode);

                optionsModal.style.display = 'block';
            }
            
            function closeOptionsModal() {
                optionsModal.style.display = 'none';
            }

            function setGameSpeed(speed) {
                gameSpeedMultiplier = speed;
                speedButtons.forEach(btn => btn.classList.toggle('active', parseFloat(btn.textContent) === speed));
                
                if (!waveInProgress && wavePauseTimer > 0) {}
            }

            function togglePlacementMode(type, mode) {
                if (!gameStarted) {
                    showMessage('Start the game first!');
                    return;
                }
                
                const config = TOWER_CONFIGS[type];
                const currentCost = getTowerCost(type);
                if (money < currentCost) {
                     showMessage(`Not enough money! You need $${currentCost} for a ${config.name}.`);
                     if (type !== selectedTowerType) return;
                }

                if (towerModal.style.display === 'block') closeTowerModal();
                if (optionsModal.style.display === 'block') closeOptionsModal();
                
                if (type) selectedTowerType = type;

                if (mode === 'single') {
                    if (placingTower && selectedTowerType === type) {
                        placingTower = false;
                        continuousPlacement = false; 
                        showMessage('');
                    } else {
                        placingTower = true;
                        continuousPlacement = false; 
                        showMessage(`Click on the map to place a single ${config.name} ($${currentCost}).`, 'blue');
                    }
                } else if (mode === 'continuous') {
                    continuousPlacement = !continuousPlacement; 
                    
                    if (continuousPlacement) {
                        placingTower = false; 
                        showMessage(`Click or drag on the map to place ${TOWER_CONFIGS[selectedTowerType].name} continuously.`, 'blue');
                    } else {
                        showMessage('');
                    }
                }

                updatePlacementButtonStyles();
                draw();
            }
            
            function renderLevelSelector() {
                levelSelectorEl.innerHTML = '';
                Object.entries(LEVEL_PATHS).forEach(([id, levelData]) => {
                    const button = document.createElement('button');
                    button.id = `select-level-${id}`;
                    button.textContent = levelData.name;
                    button.className = 'btn-tower flex flex-col items-center justify-center h-20 text-center text-lg bg-green-600 hover:bg-green-700';
                    
                    button.addEventListener('click', () => selectLevel(id));
                    levelSelectorEl.appendChild(button);
                });
                if (currentLevelId) selectLevel(currentLevelId); 
            }

            function selectLevel(id) {
                currentLevelId = id;
                levelMessage.textContent = '';
                menuStartButton.disabled = false;
                menuStartButton.textContent = `Start Game on ${LEVEL_PATHS[id].name.split(': ')[1]}`;

                Object.keys(LEVEL_PATHS).forEach(key => {
                    const button = document.getElementById(`select-level-${key}`);
                    if (button) {
                        button.classList.remove('selected', 'bg-yellow-500', 'ring-4', 'ring-yellow-300');
                        button.classList.add('bg-green-600', 'hover:bg-green-700');
                        if (key === id) button.classList.add('selected', 'bg-yellow-500', 'ring-4', 'ring-yellow-300');
                    }
                });
            }


            canvas.addEventListener('click', (e) => {
                if (!gameStarted) return;

                const { x, y } = getMousePos(canvas, e);

                if (checkCoinClick(x, y)) return;

                const clickedTower = findClickedTower(x, y);

                if (clickedTower) {
                    if (!placingTower && !continuousPlacement) openTowerModal(clickedTower);
                    return;
                }

                if (placingTower) {
                    if (attemptTowerPlacement(x, y, false)) {
                        placingTower = false;
                        updatePlacementButtonStyles();
                        showMessage('');
                    }
                }
            });
            
            let isMouseDown = false;
            canvas.addEventListener('mousedown', (e) => {
                if (gameStarted && continuousPlacement) {
                    isMouseDown = true;
                    const { x, y } = getMousePos(canvas, e);
                    
                    const snapped = getSnappedCoords(x, y); 
                    lastSnappedCoord = snapped; 

                    attemptTowerPlacement(x, y, true);
                }
            });

            canvas.addEventListener('mouseup', () => isMouseDown = false);

            canvas.addEventListener('mousemove', (e) => {
                lastMouseEvent = e;
                if (gameStarted && continuousPlacement && isMouseDown) {
                    const { x, y } = getMousePos(canvas, e);
                    
                    let currentSnapped;
                    if (freePlacement) currentSnapped = getSnappedCoords(x, y); 
                    else currentSnapped = getSnappedCoords(x, y);


                    if (currentSnapped.x === lastSnappedCoord.x && currentSnapped.y === lastSnappedCoord.y) return; 
                    lastSnappedCoord = currentSnapped; 

                    attemptTowerPlacement(x, y, true); 
                }
                if(placingTower || continuousPlacement) draw(); 
            });


            continuousPlacementButton.addEventListener('click', () => {
                if (!TOWER_CONFIGS[selectedTowerType]) selectedTowerType = 'BASE'; 
                togglePlacementMode(selectedTowerType, 'continuous');
            });
            
            optionsButton.addEventListener('click', openOptionsModal);

            toggleSoundButton.addEventListener('click', toggleSound);
            modalDebugToggle.addEventListener('click', () => {
                handleDebugToggle();
                closeOptionsModal();
            });
            resetGameButton.addEventListener('click', () => {
                endGame(false);
                closeOptionsModal();
                document.querySelector('#mainMenuContainer h1').textContent = 'Game Reset';
                levelMessage.textContent = 'Select a level to begin a new game.';
            });

            startButton.addEventListener('click', () => {
                if (gameStarted && !waveInProgress) { 
                    startNextWave();
                    startButton.disabled = true; 
                    
                    placingTower = false;
                    continuousPlacement = false;
                    updatePlacementButtonStyles();
                }
            });

            menuStartButton.addEventListener('click', () => {
                if (!currentLevelId) {
                    levelMessage.textContent = 'Please select a level first!';
                    return;
                }
                mainMenuContainer.classList.add('hidden');
                gameUiContainer.classList.remove('hidden');
                resetGame(); 
            });

            freePlacementCheckbox.addEventListener('change', () => {
                freePlacement = freePlacementCheckbox.checked;
                if (placingTower || continuousPlacement) {
                     placingTower = false;
                     continuousPlacement = false;
                     updatePlacementButtonStyles();
                     showMessage('Placement mode reset due to Free Placement change.', 'red');
                }
                draw();
            });

            renderLevelSelector();
            drawPath(); 
            
            requestAnimationFrame(update);

            modalClose.addEventListener('click', closeTowerModal);
            optionsModalClose.addEventListener('click', closeOptionsModal);

            speedButtons[0].addEventListener('click', () => setGameSpeed(1));
            speedButtons[1].addEventListener('click', () => setGameSpeed(2));
            speedButtons[2].addEventListener('click', () => setGameSpeed(4));
            
            debugToggleBtn.addEventListener('click', handleDebugToggle); 

            volumeSlider.addEventListener('input', (e) => {
                masterVolume.volume.value = e.target.value;
            });

            window.addEventListener('click', (event) => {
                if (event.target == towerModal) closeTowerModal();
                if (event.target == optionsModal) closeOptionsModal();
            });
        });
    </script>

</body>
</html>